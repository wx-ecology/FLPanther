---
title: "Panther_cLogit_FINAL"
author: "Wenjing"
date: "02/04/2022"
output: html_document
---

This document is for the final analysis for the panther paper. The paper will be using 100 (97 random pts), and the result for 10 pts and 50 pts will be included in supplementary material. 

June 1st update: exclude dev variable from the beginning
Feb 4 2022 update: use circle buffer to estimate HR.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(survival)
library(dplyr)
library(ggplot2)
library(viridis)
library(GGally)
library(MuMIn)
library(AICcmodavg)
library(cowplot)
library(aod)
library(lmtest)
library(hrbrthemes)
```

## dataframe prep
```{r data prep}
# reclassify vegetation class
data <- read_csv("./allpts_Extraction_2022.csv") %>% dplyr:: select(-'system:index', -.geo) %>% rename (Perc_Tree = Prec_Tree, Used = used )
data <- data %>% filter(!CLC_STATE %in% c(3200,4200, 5000, 5250)) # get rid of random points that fall in water
sum  <- data %>% group_by(Den_ID) %>% summarise(n = n())

data.0 <- data %>% filter(Used == 0) %>% group_by(Den_ID) %>% sample_n(100)  # now every den has 100 corresponding random points
data <- rbind((data %>% filter(Used == 1)), data.0)
#sum  <- data %>% group_by(Den_ID) %>% summarise(n = n())

# regroup CLC vegetation classes
veg.code <- read.csv("VegCombineCode.csv")
# reshape data
data <- data  %>% dplyr::left_join(veg.code, by = "CLC_STATE") %>%
  # specify factors. Levels order will affect the baseline level in the modeling process
  mutate(Den_ID = as.factor(Den_ID),
         Fire_Cat = factor(data$Fire_Cat, levels = c("U", "A", "B", "C", "D")))

data <- data %>% dplyr::select(Used, Den_ID, Fire_Cat, Ave_Wet, Perc_Tree, Combined) %>% dplyr::rename(Veg_Class = Combined)
data$Veg_Class <- factor(data$Veg_Class, levels = c("Upland Forest", "Other", "Marsh-Shrub-Swamp", "Prairie-Grassland", "Wetland Forest"))
data$Veg_Class <- relevel(data$Veg_Class, ref = 5)

data <- data %>% dplyr::arrange (Den_ID) %>%
  mutate(Perc_Tree_raw = Perc_Tree,
          Ave_Wet = scale(Ave_Wet),
         Perc_Tree = scale(Perc_Tree))
```

## Fitting 
```{r fitting round 1}
# STEP 1: full model
cand.models.1 <- list()
cand.models.1[[1]] <- clogit(Used ~ Fire_Cat:Perc_Tree + Perc_Tree:Veg_Class + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet + strata(Den_ID), data = data, method='efron')
cand.models.1[[2]] <- clogit(Used ~ Fire_Cat:Perc_Tree + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet  + strata(Den_ID), data = data, method='efron')
cand.models.1[[3]] <- clogit(Used ~  Perc_Tree:Veg_Class + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet + strata(Den_ID), data = data, method='efron')
cand.models.1[[4]] <- clogit(Used ~ Fire_Cat + Perc_Tree + Veg_Class + Ave_Wet  + strata(Den_ID), data = data, method='efron')
Modnames <- paste("mod", 1:length(cand.models.1), sep = " ")
aictab(cand.set = cand.models.1, modnames = Modnames, sort = TRUE)
## STEP 1 RESULT - KEEP mod 4 (no interaction term)

# STEP 2: 
cand.models.2 <- list()
cand.models.2[[1]] <- cand.models.1[[4]]
cand.models.2[[2]] <- update(cand.models.1[[4]],  . ~ . - Ave_Wet)
cand.models.2[[3]] <- update(cand.models.1[[4]],  . ~ . - Perc_Tree)
cand.models.2[[4]] <- update(cand.models.1[[4]],  . ~ . - Veg_Class)
Modnames <- paste("mod", 1:length(cand.models.2), sep = " ")
aictab(cand.set = cand.models.2, modnames = Modnames, sort = TRUE)
## STEP 2 RESULT - KEEP mod 2 (no Ave_Wet)
lrtest(cand.models.2[[2]], cand.models.2[[1]])
## mod 1 and mod 2 are very close to each other. Test likelihood ratio of the two nested model (Lewis et al 2010)
## "it is actually possible to use the LRT for comparing both nested and non-nested models."
## the difference between mod 1 and mod 2 are not significant. aka the extra info added by having ave wet, which takes 1 estra degree of freedom, are not that signifant. choose mod 2 which is more parcimonious (leaving out ave wet)

# STEP 3: 
cand.models.3 <- list()
cand.models.3[[1]] <- cand.models.2[[2]]
cand.models.3[[2]] <- update(cand.models.2[[2]],  . ~ . - Perc_Tree)
cand.models.3[[3]] <- update(cand.models.2[[2]],  . ~ . - Veg_Class)
Modnames <- paste("mod", 1:length(cand.models.3), sep = " ")
aictab(cand.set = cand.models.3, modnames = Modnames, sort = TRUE)
# 1 and 3 are very close
lrtest(cand.models.3[[3]], cand.models.3[[1]])
# same reason as before. choose model 3.

# STEP 4: 
cand.models.4 <- list()
cand.models.4[[1]] <- cand.models.3[[3]]
cand.models.4[[2]] <- update(cand.models.3[[3]],  . ~ . - Perc_Tree)
Modnames <- paste("mod", 1:length(cand.models.4), sep = " ")
aictab(cand.set = cand.models.4, modnames = Modnames, sort = TRUE)
## mod 1 is better than any other 2. mod 1 is our final model.

# # whether it is better to keep fire
# cand.models.5 <- list()
# cand.models.5[[1]] <-  cand.models.4[[1]]
# cand.models.5[[2]] <- update(cand.models.4[[1]],  . ~ . - Fire_Cat)
# Modnames <- paste("mod", 1:length(cand.models.5), sep = " ")
# aictab(cand.set = cand.models.5, modnames = Modnames, sort = TRUE)
# lrtest(cand.models.5[[1]],cand.models.5[[2]])
# # better to keep fire!

final.mod <- cand.models.4[[1]]
summary(final.mod ) #include the exp(coef) table in the paper 
```

## the regression coeffecients and hazard ratios (will not include as a graph in the paper)
```{r confidence interval} 
co.table <- cbind(OR = coef(final.mod), confint(final.mod))
co.df <- data.frame(variable = row.names(co.table), estimate = co.table[1:nrow(co.table), 1], LL = co.table[1:nrow(co.table), 2], UL =  co.table[1:nrow(co.table), 3])
co.df$variable <- as.character(co.df$variable)
ggplot(co.df, aes(y=estimate, x=variable, ymin=LL, ymax=UL)) + geom_pointrange() + coord_flip()

co.table <- cbind(OR = exp(coef(final.mod)), exp(confint(final.mod)))
co.df <- data.frame(variable = row.names(co.table), estimate = co.table[1:nrow(co.table), 1], LL = co.table[1:nrow(co.table), 2], UL =  co.table[1:nrow(co.table), 3])
co.df$variable <- as.character(co.df$variable)
ggplot(co.df, aes(y=estimate, x=variable, ymin=LL, ymax=UL)) + geom_pointrange() + coord_flip() 
```


```{r response curve figure}
newdata <- data.frame(Den_ID = factor(data$Den_ID[6]), 
                      Fire_Cat = factor(rep(c("A", "B", "C", "D", "U"), each = 100)),
                      Perc_Tree = rep(seq(from = min(data$Perc_Tree), to = max(data$Perc_Tree), length.out = 100), 5)) # in original data the min and the max is 0 and 100. later will scale back 

newdata <- cbind(newdata, predict(final.mod, newdata = newdata, type = "lp", se = TRUE))
newdata <- within(newdata, {
  PredictedProb <- plogis(fit)
  LL <- plogis(fit - (1.96 * se.fit))
  UL <- plogis(fit + (1.96 * se.fit))
})

newdata.2 <- newdata
names(newdata.2)[2] <- "Year_Since_Last_Fire"
year <- newdata.2 %>% dplyr::select("Year_Since_Last_Fire") 
year <- as.character(year$`Year_Since_Last_Fire`) %>% dplyr::recode(A = "<2", B = "2-3", C = "3-4", D = "4-5", U = ">5")
newdata.2$`Year_Since_Last_Fire` <- factor(year, levels = c("<2", "2-3", "3-4", "4-5", ">5"))
newdata.2$Perc_Tree <- rescale(newdata$Perc_Tree, to = c(0, 100))

ggplot(newdata.2, aes(x = Perc_Tree, y = PredictedProb)) + 
  geom_ribbon(aes(ymin = LL,
  ymax = UL, fill = Year_Since_Last_Fire), alpha = 0.2) + 
  geom_line(aes(colour = Year_Since_Last_Fire, linetype = Year_Since_Last_Fire), size = 1.8)  + 
  theme_ipsum(base_size = 12, axis_title_size = 14) +  
  theme(legend.position = c(0.8,0.2)) + 
  scale_fill_viridis(discrete = T, option = "A") +
  scale_color_viridis(discrete = T, option = "A") +
  ylab("Probability") +
  xlab("Percent Tree Cover") +
  theme(legend.background = element_rect(fill="lightgrey", size = 0.5)) +
  theme(legend.title = element_text(size=14)) +
  theme(legend.text = element_text(size=12))
```




## 50 random pts
```{r}
set.seed(17)
data.1 <- data %>% group_by (Den_ID) %>% filter( Used == 1)
data.50 <- data %>% group_by (Den_ID) %>% filter( Used == 0 ) %>% sample_n(50)
data <- dplyr::union(data.1, data.50) %>% arrange(Den_ID)

# STEP 1: full model
cand.models.1 <- list()
cand.models.1[[1]] <- clogit(Used ~ Fire_Cat:Perc_Tree + Perc_Tree:Veg_Class + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet + strata(Den_ID), data = data, method='efron')
cand.models.1[[2]] <- clogit(Used ~ Fire_Cat:Perc_Tree + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet  + strata(Den_ID), data = data, method='efron')
cand.models.1[[3]] <- clogit(Used ~  Perc_Tree:Veg_Class + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet + strata(Den_ID), data = data, method='efron')
cand.models.1[[4]] <- clogit(Used ~ Fire_Cat + Perc_Tree + Veg_Class + Ave_Wet  + strata(Den_ID), data = data, method='efron')
Modnames <- paste("mod", 1:length(cand.models.1), sep = " ")
aictab(cand.set = cand.models.1, modnames = Modnames, sort = TRUE)
## STEP 1 RESULT - KEEP mod 4 (no interaction term)
#summary(cand.models.1[[4]])

# STEP 2: 
cand.models.2 <- list()
cand.models.2[[1]] <- cand.models.1[[4]]
cand.models.2[[2]] <- update(cand.models.1[[4]],  . ~ . - Ave_Wet)
cand.models.2[[3]] <- update(cand.models.1[[4]],  . ~ . - Perc_Tree)
cand.models.2[[4]] <- update(cand.models.1[[4]],  . ~ . - Veg_Class)
Modnames <- paste("mod", 1:length(cand.models.2), sep = " ")
aictab(cand.set = cand.models.2, modnames = Modnames, sort = TRUE)
## STEP 2 RESULT - KEEP mod 2 (no Ave wet)

# STEP 3: 
cand.models.3 <- list()
cand.models.3[[1]] <- cand.models.2[[2]]
cand.models.3[[2]] <- update(cand.models.2[[2]],  . ~ . - Perc_Tree)
cand.models.3[[3]] <- update(cand.models.2[[2]],  . ~ . - Veg_Class)
Modnames <- paste("mod", 1:length(cand.models.3), sep = " ")
aictab(cand.set = cand.models.3, modnames = Modnames, sort = TRUE)
# 2 and 3 are nearly the same
lrtest(cand.models.3[[3]], cand.models.3[[1]])
# keep 3, more parcimonious 

# STEP 4: 
cand.models.4 <- list()
cand.models.4[[1]] <- cand.models.3[[3]]
cand.models.4[[2]] <- update(cand.models.3[[3]],  . ~ . - Perc_Tree)
Modnames <- paste("mod", 1:length(cand.models.4), sep = " ")
aictab(cand.set = cand.models.4, modnames = Modnames, sort = TRUE)
## mod 1 is better than any other 2. mod 1 is our final model.

# whether it is better to keep fire 
cand.models.5 <- list()
cand.models.5[[1]] <-  cand.models.4[[1]]
cand.models.5[[2]] <- update(cand.models.4[[1]],  . ~ . - Fire_Cat)
Modnames <- paste("mod", 1:length(cand.models.5), sep = " ")
aictab(cand.set = cand.models.5, modnames = Modnames, sort = TRUE)
lrtest(cand.models.5[[1]],cand.models.5[[2]])

# list1 <- list()
# list1[[1]] <- cand.models.4[[1]]
# list1[[2]] <- clogit(Used ~ Perc_Tree + L.dist2build + strata(Den_ID), data = data, method='efron')
# Modnames <- paste("mod", 1:length(list1), sep = " ")
# aictab(cand.set = list1, modnames = Modnames, sort = TRUE)

final.mod <- cand.models.4[[1]]
summary(final.mod ) #include the exp(coef) table in the paper 
```

## 10 random pts
```{r}
set.seed(17)
data.10 <- data %>% group_by (Den_ID) %>% filter( Used == 0 ) %>% sample_n(10)
data <- dplyr::union(data.1, data.10) %>% arrange(Den_ID)

# STEP 1: full model
cand.models.1 <- list()
cand.models.1[[1]] <- clogit(Used ~ Fire_Cat:Perc_Tree + Perc_Tree:Veg_Class + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet + strata(Den_ID), data = data, method='efron')
cand.models.1[[2]] <- clogit(Used ~ Fire_Cat:Perc_Tree + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet  + strata(Den_ID), data = data, method='efron')
cand.models.1[[3]] <- clogit(Used ~  Perc_Tree:Veg_Class + Perc_Tree + Fire_Cat + Veg_Class + Ave_Wet + strata(Den_ID), data = data, method='efron')
cand.models.1[[4]] <- clogit(Used ~ Fire_Cat + Perc_Tree + Veg_Class + Ave_Wet  + strata(Den_ID), data = data, method='efron')
Modnames <- paste("mod", 1:length(cand.models.1), sep = " ")
aictab(cand.set = cand.models.1, modnames = Modnames, sort = TRUE)
## STEP 1 RESULT - KEEP mod 4 (no interaction term)
#summary(cand.models.1[[2]])
lrtest(cand.models.1[[3]],cand.models.1[[4]])
# choose 4

# STEP 2: 
cand.models.2 <- list()
cand.models.2[[1]] <- cand.models.1[[4]]
cand.models.2[[2]] <- update(cand.models.1[[4]],  . ~ . - Ave_Wet)
cand.models.2[[3]] <- update(cand.models.1[[4]],  . ~ . - Perc_Tree)
cand.models.2[[4]] <- update(cand.models.1[[4]],  . ~ . - Veg_Class)
Modnames <- paste("mod", 1:length(cand.models.2), sep = " ")
aictab(cand.set = cand.models.2, modnames = Modnames, sort = TRUE)
## STEP 2 RESULT - KEEP mod 2 (no Ave_wet)

# STEP 3: 
cand.models.3 <- list()
cand.models.3[[1]] <- cand.models.2[[2]]
cand.models.3[[2]] <- update(cand.models.2[[2]],  . ~ . - Perc_Tree)
cand.models.3[[3]] <- update(cand.models.2[[2]],  . ~ . - Veg_Class)
Modnames <- paste("mod", 1:length(cand.models.3), sep = " ")
aictab(cand.set = cand.models.3, modnames = Modnames, sort = TRUE)
## mod 1 and mod 4 are very close to each other. Test likelihood ratio of the two nested model (Lewis et al 2010)
lrtest(cand.models.3[[1]],cand.models.3[[3]])
## the difference between mod 1 and mod 4 are not significant. aka the extra info added by having veg_class, which takes 4 degree of freedom, are not that signifant. choose mod 4 (leaving out veg_class)

# STEP 4: 
cand.models.4 <- list()
cand.models.4[[1]] <- cand.models.3[[3]]
cand.models.4[[2]] <- update(cand.models.3[[3]],  . ~ . - Perc_Tree)
Modnames <- paste("mod", 1:length(cand.models.4), sep = " ")
aictab(cand.set = cand.models.4, modnames = Modnames, sort = TRUE)
## mod 1 is better than any other 2. mod 1 is our final model.

# whether it is better to keep fire 
cand.models.5 <- list()
cand.models.5[[1]] <-  cand.models.4[[1]]
cand.models.5[[2]] <- update(cand.models.4[[1]],  . ~ . - Fire_Cat)
Modnames <- paste("mod", 1:length(cand.models.5), sep = " ")
aictab(cand.set = cand.models.5, modnames = Modnames, sort = TRUE) # yes better to keep fire
lrtest(cand.models.5[[1]],cand.models.5[[2]])

# list1 <- list()
# list1[[1]] <- cand.models.4[[1]]
# list1[[2]] <- clogit(Used ~ Perc_Tree + L.dist2build + strata(Den_ID), data = data, method='efron')
# Modnames <- paste("mod", 1:length(list1), sep = " ")
# aictab(cand.set = list1, modnames = Modnames, sort = TRUE)

final.mod <- cand.models.4[[1]]
summary(final.mod ) #include the exp(coef) table in the paper 
```